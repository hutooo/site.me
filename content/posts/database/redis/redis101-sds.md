---
title: RedisDIY - 简单动态字符串[SDS]
author: ash
tags: ["Redis", "NoSQL"]
categories: ["存储探秘", "Hacking", "DIY"]
date: 2021-04-12T19:46:47+08:00
cover: "/images/miku01.jpg"
---


# 0x01 Redis的简单动态字符串 SDS

SDS的数据结构

```c
struct sdshdr {
    // 记录buf中已使用的字节数量, 即SDS中字符串的长度
    int len;
    // 记录buf中未使用的字节数量
    int free;
    // 字节数组, 用于保存字符串
    // 遵循C字符串结尾保存'\0'空字符, 以便于直接使用C字符串函数
    // 结尾的'\0'不计入len长度中
    char buf[];
}
```

## 为什么使用SDS

一句话: C字符串并不能满足Redis对性能与安全的要求.

1. 长度获取 对应 STRLEN 指令

> C字符串并不记录自身长度信息，因此获取字符串长度需要O(N)的时间复杂度;
>
> 而SDS记录了长度信息，通过`len`属性，可以在O(1)时间内获取长度

2. 防止缓冲区溢出

> C语言中的字符串拼接函数 `strcat` 无法保证内存安全
>
> SDS会先检查空间是否满足修改需求

3. 降低内存重分配的次数

> 正因为C字符串不记录长度，也没有冗余的空间存放额外的字符；所以每次长度的修改，都需要进行内存重分配
>
> SDS通过未使用空间解除了字符串长度与数组长度的关联，通过空间预分配和惰性空间释放策略，极大的优化性能

4. 二进制安全

> C字符串除了末尾之外，其余部分不能包含'\0'，这使得C字符串无法保存二进制数据
>
> SDS使用len属性而非结尾的空字符来判断长度，因此保存特殊的数据格式没有任何问题

5. 兼容部分C字符串函数


## C字符串与SDS的差异总结

|C字符串|SDS|
|:-:|:-:|
|获取字符串长度的复杂度O(N)|获取字符串长度的复杂度O(1)|
|API不安全，可能造成缓冲区溢出|API安全|
|修改N次长度，必须执行N次内存重分配|修改N次长度，最多执行N次内存重分配|
|只能保存文本数据|可以保存文本或者二进制数据|
|可以使用所有的<string.h>库函数|能使用一部分<string.h>库函数|

## SDS 的主要API

|函数|功能|时间复杂度|
|:-:|---|---|
|sdsnew|创建一个包含给定C字符串的SDS|O(N), N=给定字符串的长度|
|sdsempty|创建一个空的SDS|O(1)|
|sdsfree|释放给定的SDS|O(N),N=SDS的长度|
|sdslen|返回SDS已使用的空间字节数|O(1), SDS.len|
|sdsavail|返回SDS未使用的空间|O(1), SDS.free|
|sdsdup|创建一个给定SDS的副本|O(N), N=SDS的长度|
|sdsclear|清空SDS保存的字符串内容|O(1), 因为惰性释放策略|
|sdscat|将给定字符串拼接到SDS字符串的末尾|O(N),N=被拼接字符串的长度|
|sdscatsds|将SDS拼接到另一个SDS字符串末尾|O(N),N=被拼接SDS字符串的长度|
|sdscpy|将给定的字符串复制到SDS内，覆盖原有字符串|O(N),N=被复制字符串的长度|
|sdsgrowzero|用空字符将SDS扩展到指定长度|O(N),N=扩展新增的字节数|
|sdsrange|保留SDS给定区间内的数据，非区间内的数据被覆盖或者清除|O(N),N=被保留数据的字节数|
|sdstrim|接收一个SDS和给定字符串作为参数，从SDS中移除所有给定字符串中出现的字符|O(N^2),N=给定字符串的长度|
|sdscmp|对比两个SDS的字符串是否相同|O(N),N=较短的SDS的长度|


# 0x02 Go的SDS实现

```go
type sds struct {
    buf []byte
    len int
    free int
}
```

由于 Go 中内建的 string 类型可以较好的替代 SDS 的工作，因此可以直接选用 string !!
