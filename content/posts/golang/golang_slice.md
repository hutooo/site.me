---
title: Golang数据结构 --- slice切片
author: ash
tags: ["DataStructure", "Golang", "slice"]
categories: ["Golang剖析"]
date: 2020-05-06T21:30:00+08:00
cover: "/images/vr.jpg"
---

# 0x00 什么是slice/切片

slice也称动态数组，底层依托于数组，可以实现扩容、传递...  使用上较数组更为灵活.

也因为灵活，所以必须要熟练掌握原理，才不会轻易掉入slice陷阱.

# 0x01 slice的实现原理

slice的实现依托数组(数组会对用户屏蔽)，在容量不足时能自动扩容.

## slice 数据结构

slice结构在 src/runtime/slice.go:slice  中进行了定义:

```go
type slice struct {
    // 指向底层数组
    array unsafe.Pointer
    // 长度
    len int
    // 容量
    cap int
}
```

## slice 的创建

1. 使用make语句构建slice，构建时可以传入长度和容量，底层数组的长度等于容量.

栗子:

```go
slice := make([]int, 5, 10)
```

其结构示意图如下:

```s
| slice |
---------         {-- len --}
| array | ------> |0|0|0|0|0|0|0|0|0|0|
---------         {------   cap  -----}
| len=5 |
---------
|cap=10 |
```

2. 使用数组创建slice, slice将与原数组公用一部分内存.

栗子:

```go
array := [10]int{0,1,2,3,4,5,6,7,8,9}
slice := array[5:7]
```

其结构示意图如下:

```s
| slice |
---------                   {len}
| array | ------> |0|1|2|3|4|5|6|7|8|9|
---------                   {-- cap --}
| len=2 |
---------
| cap=5 |
```

切片从数组array[5]开始，到array[7]结束(不包含array[7]). 因此切片长度为2，而5开始之后所有内容都作为切片的预留内存，因此容量时5.

> 数组和切片操作可能作用在同一块内存!!

## slice 扩容

当使用 `append` 向Slice追加元素时，如果Slice空间不足，将会触发扩容.

Slice的扩容，其实就是重新分配一块更大的内存空间，然后将原Slice数据拷贝进新的Slice.

栗子，向一个容量为5，长度也为5的slice中`append`一个新元素. 其结构示意图如下:

```s
| slice |
---------         {-- len --}
| array | ------> |1|1|1|1|1|
---------         {-- cap --}
| len=5 |
---------
| cap=5 |
---------
    |
    |
    |
  [扩容]
    |
    |
    |
    ↓
---------
| slice |
---------         {--- len ---}
| array | ------> |1|1|1|1|1|1|0|0|0|0|
---------         {-----   cap   -----}
| len=5 |
---------
| cap=10|
```

扩容遵循一定的规则：

* 如果slice容量小于1024，则新的slice容量扩大为2倍.
* 如果slice容量大于1024，则新的slice容量扩大1.25倍.

## slice 复制

使用 `copy` 内置函数复制切片时，会将源切片的数据逐个复制到目标切片指向的数组中，拷贝的数量取两个切片长度的最小值.

因此，`copy` 过程不会发生扩容.

栗子：长度10的切片拷贝到长度5的切片，只会复制5个元素.


## 特殊切片

通过数组或切片生成新的切片一般使用 slice := array[start:end] 这种方式，这样新切片的容量实际上是从start开始一直到array结束. 

举个栗子:

```go
// slice := array[start:end]

sliceA := make([]int, 5, 10)
sliceB := sliceA[0:5]

// sliceA 和 sliceB 长度和容量都是一样的, 使用相同的内存地址
```

也可以声明容量:

```go
sliceA := make([]int, 5, 10)  // len=5 cap=10
sliceB := sliceA[0:5]         // len=5 cap=10
sliceC := sliceA[0:5:5]       // len=5 cap=5
```

## Tips

* 创建切片时尽量进行容量的预分配，避免追加过程中扩容操作，有利于提升性能
* 切片拷贝时需要判断实际拷贝的元素个数
* 谨慎使用多个切片操作同一个数组，以防读写冲突
* 每个切片都指向一个底层数组
* 每个切片都保存了当前切片的长度、底层数组可用容量
* 使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片
* 使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片
* 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣
* 使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片[内存地址改变]
