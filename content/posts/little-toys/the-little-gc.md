---
title: The Little GC
author: ash
tags: ["gc"]
categories: ["LittleToys"]
date: 2021-09-25T20:39:00+08:00
cover: "/images/gc.jpg"
---


"小伙子，你是什么垃圾?" --- 垃圾回收管理员

"噢~ 可回收垃圾..."

# 0x01 什么是GC

GC 是 `Garbage Collection` 的简称，通常叫做 垃圾回收. 在 GC 中，把程序不用的内存空间视为垃圾. 

## GC是用来干嘛的?

GC针对垃圾需要做两件事.

1. 找到内存空间里的垃圾
2. 回收垃圾，让程序能再次利用这部分空间

满足这两项功能的程序就是GC.

## 使用GC的好处

在没有GC的世界里，程序员必须手动进行内存管理，必须清楚地确保必要的内存空间，释放不要的内存空间，但人总会遗漏和犯错.

* 忘记释放内存空间将会导致内存泄露，这样的程序放任不管，会把内存占满，甚至导致系统崩溃.
* 另外，在释放内存空间时，如果忘记初始化指向释放空间的指针，将产生"悬垂指针"，如果程序中误用悬垂指针，将产生难以预料的BUG，也可能导致严重的安全漏洞.

有个GC之后，就能省去人工管理内存的麻烦，同时也减轻了程序员的负担，把精力集中在更重要的地方.

> 弊端: GC算法会增加程序的运行时开销，同时大部分GC算法会有STW问题.
> 当然现在有很多更好的GC算法[一种新的引用技术算法, 参考koka语言]，也有很多别样的内存管理方法: RAII, Ownership&lifetime(所有权与生命周期)... [参考Rust语言]

# 0x02 GC基本原理 [Reduce, Reuse, Recycle]

GC背后的基本思想是，程序语言(在大多数情况下)似乎可以访问无限内存. 开发人员只需要不断地分配、分配和分配，就像变魔术一样，它永远不会失败.

当然，机器没有无限的内存. 因此，GC的实现方式是，当它需要分配内存并意识到自己的内存不足时，会收集垃圾[回收内存].

如果程序访问的对象开始被回收，就比较尴尬. 因此为了GC正常运作，必须确保程序无法再次使用这个对象. 如果它不能得到对象的引用，那么它显然不能再次使用它. 因此，"在用"可以这么定义和理解:

1. 任何被范围内的变量引用的对象都在使用中

2. 任何被另一个正在使用的对象引用的对象都在使用中

第二条规则是递归规则. 如果对象a 被一个变量引用，并且它有一些引用对象b 的字段，那么 b 就被使用了，因为你可以通过 a 找到它.

根据规则，最终呈现的是一个 可达对象 图表，你可以从一个变量开始遍历对象，对于程序来说，任何不在可访问对象图中的对象都是非活跃对象，可以回收它们的内存空间.

> 实际上，GC相当于虚拟内存. 一般的虚拟内存技术是在较小的物理内存的基础上，利用辅助存储创造一片看上去很大的“虚拟”地址空间，也就是说，GC是扩大内存空间的技术，因此我称其为空间性虚拟存储。这样一来，GC就成了永久提供一次性存储空间的时间轴方向的时间性虚拟存储. 神奇的是，比起"垃圾回收"，把GC称为"虚拟内存“令人感觉其重要了许多. --- 《垃圾回收的算法与实现》

# 0x03 GC算法

# 0x04 标记清除算法

# 0x05 一个超小型虚拟机

# 0x06 构建GC

