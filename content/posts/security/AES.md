---
title: AES 加密算法
author: ash
tags: ["AES", "Security", "安全", "密码"]
categories: ["安全攻防"]
date: 2021-06-29T18:51:10+08:00
cover: "/images/vr.jpg"
math: md
---

## 0x01 AES-简介

`AES` 是 `Advanced Encryption Standard` 的简写，意为高级加密标准.

这个标准用来替代原先的 `DES`，是一种 `区块加密标准`. 

为了寻得良好的AES，进行了5年的筛选.

最终由比利时密码学家 `Joan Daemen` 和 `Vincent Rijmen` 所設計的加密方法，結合兩位作者的名字，以 `Rijndael` 为该密码命名. 经过安全性分析、软硬件性能评估等诸多严格步骤而胜出，成为 `AES` 加密算法.

现在，AES已经成为对称密钥加密中最流行算法之一.

> PS: Rijndael算法支持 128,192,256 bits 等多种分组长度，但是AES只选用128位
> 本文选用 分组长度128位，密钥长度也为128位的AES
> 密钥长度为192位和256位的处理方式和128位的处理方式类似，只不过密钥长度每增加64位，算法的循环次数就增加2轮，128位循环10轮、192位循环12轮、256位循环14轮

|密钥长度|迭代轮数|
|:-:|:-:|
|128|10|
|192|12|
|256|14|
|||


## 0x02 AES-数学基础

> 本文并不会关注于定理公式的推导证明，也不会涉及AES的安全性证明、已知攻击...

### >> 群

什么是 群?

`群` 是由元素集合 `G` 和 二元运算 `•` 组成的代数结构.

> 二元运算 `•`，可以结合任何两个元素 `a` 和 `b` 形成另一个元素，记为 `a • b`

群具有以下特征 - [群公理]:

1. 群操作具有 封闭性
    > 对所有 `a,b ∈ G`， `c = a • b ∈ G` 恒成立
2. 群操作满足 结合律 
    > 对所有 `a,b,c ∈ G` ，`(a • b) • c = a • (b • c)` 恒成立
3. 存在 单位元/中性元
    > 存在一个元素 `e ∈ G`，对于所有 `a ∈ G` 都有 `a • e = e • a = a`，这个元素 `e` 被称为单位元 
4. 存在 逆元
    > 对于每一个 `a ∈ G` ，都存在一个元素 `i ∈ G` 使得 `a • i = i • a = e` ，`i` 称为 `a` 的逆元

> 如果在满足以上特征的基础上，对于所有的 `a,b ∈ G` 都有 `a • b = b • a` ，则称此群为阿贝尔群(或交换群).

要使一个群结构能同时支持加减乘除四种基本运算，则需要引入域的概念.

### >> 域

`域F` 是具有以下特征的元素的集合:

1. `F`中的所有元素形成一个加法交换群，对应的群操作`+`，中性元为 `0`.
2. `F` 中除 `0` 以外的所有元素构成一个乘法交换群， 对应的群操作为 `*`，中性元为 `1`.
3. 当使用这两种操作时，分配律始终成立. 即 `∀ a,b,c ∈ F, 都有 a * (b + c) = (a * b) + (a * c)`.

> PS: 实数集`R` 就是一个域, 加法群的单位元是0, 域内任意元素 a 的加法逆元是 -a; 乘法群的单位元是1, 域内除0以外任意元素 b 的乘法逆元 是 1/b.

### >> 有限域

实际AES应用中，我们更关心元素数量有限的域. 这样的域称为`有限域` 或 `伽罗瓦域`.

先引入两个定理

1. 只有当 `m` 是一个素数幂时，阶为 `m` 的域才存在.
    > 素数幂指 `m = p^n`，其中 `n` 为正整数， `p` 为素数也称为这个有限域的特征.
    > `阶` 指的是有限域内的元素个数.
    > 当 `n=1` 时，该域称为素域， `n >= 2` 时称为 扩展域

2. 假设 `p` 是一个素数，整数环`Zp` 表示为`GF(p)`，是拥有素数个元素的有限域. `GF(p)` 中的所有非零元素都存在逆元，`GF(p)` 内的算术运算都通过 `模p` 实现.

#### 举个栗子吧~ 

有限域 GF(5) = {0,1,2,3,4}，还记得单位元和逆元嘛~

在GF(5)中，2的加法逆元为3，因为 2 + 3 = 0 mod 5；
2的乘法逆元也是3，因为 2 * 3 = 1 mod 5 .

再看看这个~

有限域 GF(2) = {0, 1}，是最小的有限域，看一下它的加法和乘法运算

|加法|乘法|
|---|---|
|0 + 0 = 0 mod 2| 0 * 0 = 0 mod 2|
|0 + 1 = 1 mod 2| 0 * 1 = 0 mod 2|
|1 + 0 = 1 mod 2| 1 * 0 = 0 mod 2|
|1 + 1 = 0 mod 2| 1 * 1 = 1 mod 2|

哎~ 这个加法和乘法运算，分别和逻辑门中的 `异或门` 和 `与门` 等价.

#### 扩展域

目前AES处理的最小单位是一个字节，也就是一个二进制的8位无符号整数. 而要容纳这些整数，自然选择 $GF(2^8)$ 这个扩展域.

> 在扩展域中，元素并不用数字来表示，而是使用多项式.

$GF(2^8)$ 中的元素 `A` 表示为:

$$
A(x) = a_7x^{7} + a_6x^{6} + a_5x^{5} + a_4x^{4} + a_3x^{3} + a_2x^{2} + a_1x + a_0
$$

其中 $a_i$ 属于 $GF(2) = \{0, 1\}$

在计算机中，A(x)可以用向量 $(a7,a6,a5,a4,a3,a2,a1,a0)$ 表示系数, 而 $x^k$ 这样的项并不需要存储.

#### GF(2^8)内的加减法

随意选两个元素，比如：

$A(x) = x^7 + x^6 + x^4 + 1$

$B(x) = x^4 + x^2 + 1$

先看加法，非常简单，对应的系数异或相加模2

$A(x) + B(x) = x^7 + x^6 + 2 * x^4 + x^2 + 2 * 1$

∵ $2 * x^4 = 0\ mod\ 2, \quad 2 * 1 = 0\ mod\ 2$

∴ $A(x) + B(x) = x^7 + x^6 + x^2$

再看减法

$$
\begin{aligned}
A(x)-B(x)
&= x^7 + x^6 + x^4 + 1 - x^4 - x^2 - 1\\\\
&= x^7 + x^6 - x^2\\\\
&= x^7 + x^6 - x^2 + 2 * x^2\\\\
&= x^7 + x^6 + x^2
\end{aligned}
$$


发现减法和加法是等价的!

> 这并不是偶然, $(a + b) mod 2 = (a - b) mod 2$

#### GF(2^8)内的乘法

再选两个元素:

$A(x) = x^5 + x^2 + x^1$

$B(x) = x^7 + x^4 + x^3 + x^2 + x^1$

进行乘法运算:

$$
\begin{align*}
A(x) * B(x)
&= (x^5 + x^2 + x^1) * (x^7 + x^4 + x^3 + x^2 + x^1)\\\\
&= x^{12} + x^9 + x^9 + x^8 + x^8 + x^7 + x^6 + x^6 + x^5 + x^5 + x^4 + x^4 + x^3 + x^3 + x^2\\\\
&= x^{12} + x^7 + x^2
\end{align*}
$$

这... 出问题了, $x^{12}$ 无法用 $GF(2^8)$ 来表达. 怎么办呢~

> 在定义 $GF(2^8)$ 的乘法时，还要选择一个合适的多项式来进行模约.
> 
> AES标准中， 作者设计了一个不可约多项式 `P(x)` 来进行模约. $P(x) = x^8 + x^4 + x^3+ x^1 + 1$

那么赶紧来试一下..

$$
\begin{align}
A(x) * B(x) 
&= (x^5 + x^2 + x^1) * (x^7 + x^4 + x^3 + x^2 + x^1)\\\\
&= (x^12 + x^7 + x^2)\ mod\ P(x)\\\\
&= (x^12 + x^7 + x^2)\ mod\ (x^8 + x^4 + x^3 + x^1 + 1)
\end{align}
$$

$$
\begin{align}
∵ (x^{12} + x^7 + x^2)\ mod\ P(x)
&=(x^{12} + x^7 + x^2)\ mod\ (x^8 + x^4 + x^3 + x^1 + 1)\\\\
&=(x^{12} + x^8 + x^7 + x^5 + x^4 + x^7 + x^2 - x^8 - x^7 - x^5 - x^4)\ mod\ (x^8 + x^4 + x^3 + x^1 + 1)
\\\\
&=(x^{12} + x^8 + x^7 + x^5 + x^4 + x^2 - x^8 - x^5 - x^4)\ mod\ (x^8 + x^4 + x^3 + x^1 + 1)\\\\
&=(x^{12} + x^8 + x^7 + x^5 + x^4 + x^2 + x^8 + x^5 + x^4)\ mod\ (x^8 + x^4 + x^3 + x^1 + 1)\\\\
&=(x^4 * P(x) + x^8 + x^5 + x^4 + x^2)\ mod\ (x^8 + x^4 + x^3 + x^1 + 1)\\\\
&=(x^4 * P(x) + x^8 + x^4 + x^3 + x^1 + 1 + x^5 + x^3 + x^2 + x^1 + 1)\ mod\ (P(x))\\\\
&=(x^4 * P(x) + P(x) + x^5 + x^3 + x^2 + x^1 + 1)\ mod\ (P(x))\\\\
&=(x^5 + x^3 + x^2 + x^1 + 1)\ mod\ (P(x))
\end{align}
$$

$$∴ A(x) * B(x) = x^5 + x^3 + x^2 + x^1 + 1$$

#### GF(2^8)内的乘法逆元

* GF(2^8)上定义幂运算   TODO
* 扩展欧几里得算法   TODO

## 0x03 AES-算法结构

> PS: 在密码学实践中，并不建议用户自己设计密码学算法或自己编写程序实现(已经被更专业的团体更完善的实现过了的)——因为自己并不能保证避免各种纰漏或错误，可能会引起非常严重的安全问题. ——除非你有非常专业的团队来严格审计你的算法或代码.

`AES` 会将需要处理的数据进行分组，每组16字节[也叫分块，英文中使用block]，然后依次处理.

> `AES` 是分组密码(block cipher) 而不是流密码(stream cipher)

`AES` 通过密钥来 **加密/解密** 信息，并且加解密过程使用的密钥完全相同，加密过程和解密过程具有一定的对称性，因此AES是一种对称密钥算法(symmetric-key algorithm).

```s
[128bits] [128bits] [128bits]...
```

## 0x04 AES-代码实现

## 0x05 AES-简单使用

## 0x06 参考文献

